# Obsidian Things Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build an Obsidian plugin that bidirectionally syncs tasks between Obsidian checkboxes (tagged with a configurable tag) and Things 3, with a query DSL for rendering live task views.

**Architecture:** Poll-based sync engine reads Things 3 SQLite DB (via `sqlite3` CLI) and scans vault for tagged checkboxes. Writes to Things via AppleScript (`osascript`). A code block processor renders live task queries. Five components: Sync Engine, Things Reader, Things Writer, Markdown Scanner, Code Block Renderer.

**Tech Stack:** TypeScript, Obsidian API, esbuild, vitest, child_process (spawn), sqlite3 CLI, osascript, papaparse (CSV parsing)

**Design doc:** `docs/plans/2026-02-10-obsidian-things-design.md`

---

### Task 1: Project Scaffolding

**Files:**
- Create: `manifest.json`
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `esbuild.config.mjs`
- Create: `versions.json`
- Create: `version-bump.mjs`
- Create: `.npmrc`
- Create: `.editorconfig`
- Modify: `.gitignore`
- Create: `src/main.ts` (minimal shell)
- Create: `vitest.config.ts`
- Create: `src/__mocks__/obsidian.ts`

**Step 1: Create manifest.json**

```json
{
    "id": "obsidian-things",
    "name": "Things Sync",
    "version": "0.1.0",
    "minAppVersion": "1.0.0",
    "description": "Bidirectional sync between Obsidian and Things 3",
    "author": "Kevin",
    "isDesktopOnly": true
}
```

**Step 2: Create package.json**

```json
{
    "name": "obsidian-things",
    "version": "0.1.0",
    "description": "Bidirectional sync between Obsidian and Things 3",
    "main": "main.js",
    "scripts": {
        "dev": "node esbuild.config.mjs",
        "build": "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production",
        "version": "node version-bump.mjs && git add manifest.json versions.json",
        "test": "vitest run",
        "test:watch": "vitest"
    },
    "devDependencies": {
        "@types/node": "^20.0.0",
        "esbuild": "^0.21.0",
        "obsidian": "latest",
        "typescript": "^5.4.0",
        "vitest": "^1.6.0"
    },
    "dependencies": {
        "papaparse": "^5.4.0"
    }
}
```

**Step 3: Create tsconfig.json**

```json
{
    "compilerOptions": {
        "baseUrl": "src",
        "inlineSourceMap": true,
        "inlineSources": true,
        "module": "ESNext",
        "target": "ES6",
        "allowJs": true,
        "noImplicitAny": true,
        "noImplicitThis": true,
        "noImplicitReturns": true,
        "moduleResolution": "node",
        "importHelpers": true,
        "noUncheckedIndexedAccess": true,
        "isolatedModules": true,
        "strictNullChecks": true,
        "strictBindCallApply": true,
        "allowSyntheticDefaultImports": true,
        "useUnknownInCatchVariables": true,
        "lib": ["DOM", "ES5", "ES6", "ES7"]
    },
    "include": ["src/**/*.ts"]
}
```

**Step 4: Create esbuild.config.mjs**

```javascript
import esbuild from "esbuild";
import process from "process";
import { builtinModules } from "node:module";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";

const context = await esbuild.context({
    banner: { js: banner },
    entryPoints: ["src/main.ts"],
    bundle: true,
    external: [
        "obsidian",
        "electron",
        "@codemirror/autocomplete",
        "@codemirror/collab",
        "@codemirror/commands",
        "@codemirror/language",
        "@codemirror/lint",
        "@codemirror/search",
        "@codemirror/state",
        "@codemirror/view",
        "@lezer/common",
        "@lezer/highlight",
        "@lezer/lr",
        ...builtinModules,
    ],
    format: "cjs",
    target: "es2018",
    logLevel: "info",
    sourcemap: prod ? false : "inline",
    treeShaking: true,
    outfile: "main.js",
    minify: prod,
});

if (prod) {
    await context.rebuild();
    process.exit(0);
} else {
    await context.watch();
}
```

**Step 5: Create versions.json, version-bump.mjs, .npmrc, .editorconfig**

`versions.json`:
```json
{
    "0.1.0": "1.0.0"
}
```

`version-bump.mjs`:
```javascript
import { readFileSync, writeFileSync } from "fs";

const targetVersion = process.env.npm_package_version;

let manifest = JSON.parse(readFileSync("manifest.json", "utf8"));
const { minAppVersion } = manifest;
manifest.version = targetVersion;
writeFileSync("manifest.json", JSON.stringify(manifest, null, "\t"));

let versions = JSON.parse(readFileSync("versions.json", "utf8"));
versions[targetVersion] = minAppVersion;
writeFileSync("versions.json", JSON.stringify(versions, null, "\t"));
```

`.npmrc`:
```
tag-version-prefix=""
```

`.editorconfig`:
```ini
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
indent_style = tab
indent_size = 4
tab_width = 4
```

**Step 6: Update .gitignore**

```gitignore
.vscode
*.iml
.idea
node_modules
main.js
*.map
data.json
.DS_Store
```

**Step 7: Create vitest.config.ts and obsidian mock**

`vitest.config.ts`:
```typescript
import { defineConfig } from "vitest/config";
import path from "path";

export default defineConfig({
    test: {
        globals: true,
        environment: "node",
        alias: {
            obsidian: path.resolve(__dirname, "src/__mocks__/obsidian.ts"),
        },
    },
});
```

`src/__mocks__/obsidian.ts`:
```typescript
export class Plugin {
    app: any = {};
    manifest: any = {};
    loadData = vi.fn().mockResolvedValue({});
    saveData = vi.fn().mockResolvedValue(undefined);
    addCommand = vi.fn();
    addSettingTab = vi.fn();
    addRibbonIcon = vi.fn();
    addStatusBarItem = vi.fn().mockReturnValue({ setText: vi.fn() });
    registerView = vi.fn();
    registerMarkdownCodeBlockProcessor = vi.fn();
    registerEvent = vi.fn();
    registerDomEvent = vi.fn();
    registerInterval = vi.fn();
}

export class PluginSettingTab {
    app: any;
    plugin: any;
    containerEl: any = { empty: vi.fn(), createEl: vi.fn() };
    constructor(app: any, plugin: any) {
        this.app = app;
        this.plugin = plugin;
    }
    display() {}
    hide() {}
}

export class Setting {
    constructor(_containerEl: any) {}
    setName(_name: string) { return this; }
    setDesc(_desc: string) { return this; }
    addText(cb: any) { cb({ setValue: () => ({ onChange: () => ({}) }), setPlaceholder: () => ({ setValue: () => ({ onChange: () => ({}) }) }), inputEl: {} }); return this; }
    addToggle(cb: any) { cb({ setValue: () => ({ onChange: () => ({}) }) }); return this; }
    addDropdown(cb: any) { cb({ addOption: () => ({ addOption: () => ({}) }), setValue: () => ({ onChange: () => ({}) }) }); return this; }
    addSlider(cb: any) { cb({ setLimits: () => ({ setValue: () => ({ setDynamicTooltip: () => ({ onChange: () => ({}) }) }) }) }); return this; }
    addButton(cb: any) { cb({ setButtonText: () => ({ onClick: () => ({}) }), setCta: () => ({}) }); return this; }
}

export class Notice { constructor(_message: string) {} }
export class TFile { path = ""; basename = ""; extension = ""; }

export const Platform = {
    isMacOS: true,
    isDesktopApp: true,
    isMobileApp: false,
};
```

**Step 8: Create minimal src/main.ts**

```typescript
import { Plugin } from "obsidian";

export default class ThingsSyncPlugin extends Plugin {
    async onload() {
        console.log("Things Sync: loading");
    }

    onunload() {
        console.log("Things Sync: unloading");
    }
}
```

**Step 9: Install dependencies and verify build**

Run: `npm install && npm run build`
Expected: Build succeeds, `main.js` is generated.

**Step 10: Commit**

```bash
git add -A && git commit -m "feat: scaffold obsidian plugin project"
```

---

### Task 2: Types and Interfaces

**Files:**
- Create: `src/types.ts`

**Step 1: Write the types file**

```typescript
export interface ThingsTask {
    uuid: string;
    title: string;
    status: ThingsStatus;
    type: ThingsItemType;
    notes: string;
    project: string | null;
    projectTitle: string | null;
    area: string | null;
    areaTitle: string | null;
    tags: string[];
    startDate: string | null;
    deadline: string | null;
    stopDate: number | null;
    creationDate: number;
    userModificationDate: number;
    start: ThingsStart;
    trashed: boolean;
}

export enum ThingsStatus {
    Open = 0,
    Canceled = 2,
    Completed = 3,
}

export enum ThingsItemType {
    Todo = 0,
    Project = 1,
    Heading = 2,
}

export enum ThingsStart {
    Inbox = 0,
    Anytime = 1,
    Someday = 2,
}

export interface TrackedTask {
    uuid: string;
    filePath: string;
    line: number;
    checked: boolean;
    title: string;
    lastSyncTimestamp: number;
}

export interface SyncState {
    lastSyncTimestamp: number;
    tasks: Record<string, TrackedTask>;
}

export interface ScannedTask {
    filePath: string;
    line: number;
    checked: boolean;
    title: string;
    uuid: string | null;
    rawLine: string;
}

export interface ThingsSyncSettings {
    dbPath: string;
    syncIntervalSeconds: number;
    syncOnStartup: boolean;
    syncTag: string;
    showProject: boolean;
    showDeadline: boolean;
    showArea: boolean;
    conflictResolution: "things" | "obsidian";
    syncCompleted: boolean;
    autoCreate: boolean;
    defaultProject: string;
    defaultTags: string;
    debugLogging: boolean;
    dryRun: boolean;
}

export const DEFAULT_SETTINGS: ThingsSyncSettings = {
    dbPath: "",
    syncIntervalSeconds: 30,
    syncOnStartup: true,
    syncTag: "#things",
    showProject: true,
    showDeadline: true,
    showArea: false,
    conflictResolution: "things",
    syncCompleted: true,
    autoCreate: true,
    defaultProject: "Inbox",
    defaultTags: "",
    debugLogging: false,
    dryRun: false,
};
```

**Step 2: Verify types compile**

Run: `npx tsc --noEmit`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/types.ts && git commit -m "feat: add types and interfaces"
```

---

### Task 3: Things Reader (SQLite)

**Files:**
- Create: `src/things-reader.ts`
- Create: `src/things-reader.test.ts`

**Step 1: Write tests for date decoding and DB path discovery**

`src/things-reader.test.ts`:
```typescript
import { describe, it, expect } from "vitest";
import { decodeThingsDate, findThingsDbPath } from "./things-reader";

describe("decodeThingsDate", () => {
    it("returns null for null/zero input", () => {
        expect(decodeThingsDate(null)).toBeNull();
        expect(decodeThingsDate(0)).toBeNull();
    });

    it("decodes a known date correctly", () => {
        // Things encodes dates as: year << 16 | month << 12 | day << 7
        // 2026-02-10 = 2026 << 16 | 2 << 12 | 10 << 7
        const encoded = (2026 << 16) | (2 << 12) | (10 << 7);
        expect(decodeThingsDate(encoded)).toBe("2026-02-10");
    });

    it("decodes another date correctly", () => {
        const encoded = (2025 << 16) | (12 << 12) | (25 << 7);
        expect(decodeThingsDate(encoded)).toBe("2025-12-25");
    });

    it("pads single-digit months and days", () => {
        const encoded = (2026 << 16) | (1 << 12) | (5 << 7);
        expect(decodeThingsDate(encoded)).toBe("2026-01-05");
    });
});

describe("findThingsDbPath", () => {
    it("returns empty string when base dir does not exist", () => {
        const result = findThingsDbPath("/nonexistent/path");
        expect(result).toBe("");
    });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/things-reader.test.ts`
Expected: FAIL â€” `decodeThingsDate` and `findThingsDbPath` not found.

**Step 3: Implement Things Reader**

`src/things-reader.ts`:
```typescript
import { spawn } from "child_process";
import * as os from "os";
import * as fs from "fs";
import * as path from "path";
import Papa from "papaparse";
import { ThingsTask, ThingsStatus, ThingsItemType, ThingsStart } from "./types";

const THINGS_BASE_DIR = "~/Library/Group Containers/JLMPQHK86H.com.culturedcode.ThingsMac/";
const FETCH_LIMIT = 1000;

export function decodeThingsDate(encoded: number | null): string | null {
    if (!encoded) return null;
    const year = (encoded >> 16) & 0x7FF;
    const month = (encoded >> 12) & 0xF;
    const day = (encoded >> 7) & 0x1F;
    if (year === 0 || month === 0 || day === 0) return null;
    const mm = String(month).padStart(2, "0");
    const dd = String(day).padStart(2, "0");
    return `${year}-${mm}-${dd}`;
}

export function findThingsDbPath(baseDir?: string): string {
    const resolvedBase = (baseDir || THINGS_BASE_DIR).replace("~", os.homedir());
    try {
        const entries = fs.readdirSync(resolvedBase);
        const dataDir = entries.find((e) => e.startsWith("ThingsData"));
        if (!dataDir) return "";
        return path.join(
            resolvedBase,
            dataDir,
            "Things Database.thingsdatabase",
            "main.sqlite"
        );
    } catch {
        return "";
    }
}

interface SpawnResult {
    stdout: string;
    stderr: string;
    code: number;
}

async function runSqlite(dbPath: string, query: string): Promise<SpawnResult> {
    return new Promise((resolve) => {
        const stdoutChunks: Buffer[] = [];
        const stderrChunks: Buffer[] = [];

        const child = spawn(
            "sqlite3",
            [dbPath, "-header", "-csv", "-readonly", query],
            { detached: true }
        );

        child.stdout.on("data", (chunk: Buffer) => stdoutChunks.push(chunk));
        child.stderr.on("data", (chunk: Buffer) => stderrChunks.push(chunk));
        child.on("error", (err: Error) => {
            stderrChunks.push(Buffer.from(String(err.stack), "ascii"));
        });
        child.on("close", (code: number) => {
            resolve({
                stdout: Buffer.concat(stdoutChunks).toString("utf-8"),
                stderr: Buffer.concat(stderrChunks).toString("utf-8"),
                code: code ?? 1,
            });
        });
    });
}

function parseCSV<T>(csv: string): T[] {
    return Papa.parse<T>(csv, {
        dynamicTyping: false,
        header: true,
        newline: "\n",
        skipEmptyLines: true,
    }).data;
}

interface RawTaskRow {
    uuid: string;
    title: string;
    status: string;
    type: string;
    notes: string;
    project: string;
    projectTitle: string;
    area: string;
    areaTitle: string;
    tag: string;
    startDate: string;
    deadline: string;
    stopDate: string;
    creationDate: string;
    userModificationDate: string;
    start: string;
    trashed: string;
}

function rowToTask(row: RawTaskRow): ThingsTask {
    return {
        uuid: row.uuid,
        title: row.title,
        status: Number(row.status) as ThingsStatus,
        type: Number(row.type) as ThingsItemType,
        notes: row.notes || "",
        project: row.project || null,
        projectTitle: row.projectTitle || null,
        area: row.area || null,
        areaTitle: row.areaTitle || null,
        tags: [],
        startDate: decodeThingsDate(Number(row.startDate) || null),
        deadline: decodeThingsDate(Number(row.deadline) || null),
        stopDate: Number(row.stopDate) || null,
        creationDate: Number(row.creationDate),
        userModificationDate: Number(row.userModificationDate),
        start: Number(row.start) as ThingsStart,
        trashed: row.trashed === "1",
    };
}

const TASKS_QUERY = `
SELECT
    T.uuid, T.title, T.status, T.type, T.notes,
    T.project, P.title as projectTitle,
    T.area, A.title as areaTitle,
    GROUP_CONCAT(TG.title) as tag,
    T.startDate, T.deadline, T.stopDate,
    T.creationDate, T.userModificationDate,
    T.start, T.trashed
FROM TMTask T
LEFT JOIN TMTask P ON P.uuid = T.project
LEFT JOIN TMArea A ON A.uuid = T.area
LEFT JOIN TMTaskTag TT ON TT.tasks = T.uuid
LEFT JOIN TMTag TG ON TG.uuid = TT.tags
WHERE T.trashed = 0 AND T.type = 0
GROUP BY T.uuid
`;

export async function readAllTasks(dbPath: string): Promise<ThingsTask[]> {
    const result = await runSqlite(dbPath, TASKS_QUERY);
    if (result.stderr) {
        throw new Error(`SQLite error: ${result.stderr}`);
    }
    const rows = parseCSV<RawTaskRow>(result.stdout);
    return rows.map((row) => {
        const task = rowToTask(row);
        task.tags = row.tag ? row.tag.split(",").map((t) => t.trim()) : [];
        return task;
    });
}

export async function readTasksSince(
    dbPath: string,
    sinceTimestamp: number
): Promise<ThingsTask[]> {
    const query = `${TASKS_QUERY} HAVING T.userModificationDate > ${sinceTimestamp}`;
    const result = await runSqlite(dbPath, query);
    if (result.stderr) {
        throw new Error(`SQLite error: ${result.stderr}`);
    }
    const rows = parseCSV<RawTaskRow>(result.stdout);
    return rows.map((row) => {
        const task = rowToTask(row);
        task.tags = row.tag ? row.tag.split(",").map((t) => t.trim()) : [];
        return task;
    });
}
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run src/things-reader.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/things-reader.ts src/things-reader.test.ts && git commit -m "feat: add Things SQLite reader with date decoding"
```

---

### Task 4: Things Writer (AppleScript)

**Files:**
- Create: `src/things-writer.ts`
- Create: `src/things-writer.test.ts`

**Step 1: Write tests for AppleScript command building**

`src/things-writer.test.ts`:
```typescript
import { describe, it, expect } from "vitest";
import { buildCreateScript, buildCompleteScript, buildReopenScript } from "./things-writer";

describe("buildCreateScript", () => {
    it("builds a create script with title only", () => {
        const script = buildCreateScript("Buy groceries");
        expect(script).toContain('make new to do');
        expect(script).toContain('name:"Buy groceries"');
    });

    it("escapes double quotes in title", () => {
        const script = buildCreateScript('Read "The Book"');
        expect(script).toContain('name:"Read \\"The Book\\""');
    });
});

describe("buildCompleteScript", () => {
    it("builds a complete script", () => {
        const script = buildCompleteScript("ABC-123");
        expect(script).toContain('set status of to do id "ABC-123" to completed');
    });
});

describe("buildReopenScript", () => {
    it("builds a reopen script", () => {
        const script = buildReopenScript("ABC-123");
        expect(script).toContain('set status of to do id "ABC-123" to open');
    });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/things-writer.test.ts`
Expected: FAIL â€” functions not found.

**Step 3: Implement Things Writer**

`src/things-writer.ts`:
```typescript
import { spawn } from "child_process";

interface AppleScriptResult {
    stdout: string;
    stderr: string;
    code: number;
}

async function runAppleScript(script: string): Promise<AppleScriptResult> {
    return new Promise((resolve) => {
        const stdoutChunks: Buffer[] = [];
        const stderrChunks: Buffer[] = [];

        const child = spawn("osascript", ["-e", script], { detached: true });

        child.stdout.on("data", (chunk: Buffer) => stdoutChunks.push(chunk));
        child.stderr.on("data", (chunk: Buffer) => stderrChunks.push(chunk));
        child.on("error", (err: Error) => {
            stderrChunks.push(Buffer.from(String(err.stack), "ascii"));
        });
        child.on("close", (code: number) => {
            resolve({
                stdout: Buffer.concat(stdoutChunks).toString("utf-8").trim(),
                stderr: Buffer.concat(stderrChunks).toString("utf-8").trim(),
                code: code ?? 1,
            });
        });
    });
}

function escapeAppleScript(str: string): string {
    return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

export function buildCreateScript(title: string, project?: string): string {
    const escapedTitle = escapeAppleScript(title);
    let props = `name:"${escapedTitle}"`;
    if (project && project !== "Inbox") {
        props += `, project:project "${escapeAppleScript(project)}"`;
    }
    return `tell application "Things3" to make new to do with properties {${props}}`;
}

export function buildCompleteScript(uuid: string): string {
    return `tell application "Things3" to set status of to do id "${uuid}" to completed`;
}

export function buildReopenScript(uuid: string): string {
    return `tell application "Things3" to set status of to do id "${uuid}" to open`;
}

export function buildUpdateTitleScript(uuid: string, title: string): string {
    const escaped = escapeAppleScript(title);
    return `tell application "Things3" to set name of to do id "${uuid}" to "${escaped}"`;
}

export async function createTask(
    title: string,
    project?: string
): Promise<string> {
    const script = buildCreateScript(title, project);
    const result = await runAppleScript(script);
    if (result.stderr) {
        throw new Error(`AppleScript error: ${result.stderr}`);
    }
    // AppleScript returns the id of the created to do
    return result.stdout;
}

export async function completeTask(uuid: string): Promise<void> {
    const result = await runAppleScript(buildCompleteScript(uuid));
    if (result.stderr) {
        throw new Error(`AppleScript error: ${result.stderr}`);
    }
}

export async function reopenTask(uuid: string): Promise<void> {
    const result = await runAppleScript(buildReopenScript(uuid));
    if (result.stderr) {
        throw new Error(`AppleScript error: ${result.stderr}`);
    }
}

export async function updateTaskTitle(
    uuid: string,
    title: string
): Promise<void> {
    const result = await runAppleScript(buildUpdateTitleScript(uuid, title));
    if (result.stderr) {
        throw new Error(`AppleScript error: ${result.stderr}`);
    }
}

export async function getTaskUuid(title: string): Promise<string> {
    const escaped = escapeAppleScript(title);
    const script = `tell application "Things3" to get id of to do named "${escaped}"`;
    const result = await runAppleScript(script);
    if (result.stderr) {
        throw new Error(`AppleScript error: ${result.stderr}`);
    }
    return result.stdout;
}
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run src/things-writer.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/things-writer.ts src/things-writer.test.ts && git commit -m "feat: add Things AppleScript writer"
```

---

### Task 5: Markdown Scanner

**Files:**
- Create: `src/markdown-scanner.ts`
- Create: `src/markdown-scanner.test.ts`

**Step 1: Write tests for markdown scanning**

`src/markdown-scanner.test.ts`:
```typescript
import { describe, it, expect } from "vitest";
import { parseLine, buildTaskLine, extractTagFromLine } from "./markdown-scanner";

describe("parseLine", () => {
    const tag = "#things";

    it("parses an unchecked task with no UUID", () => {
        const result = parseLine("- [ ] Buy groceries #things", tag);
        expect(result).not.toBeNull();
        expect(result!.checked).toBe(false);
        expect(result!.title).toBe("Buy groceries");
        expect(result!.uuid).toBeNull();
    });

    it("parses a checked task with UUID", () => {
        const result = parseLine(
            "- [x] Call dentist #things %%things:ABC-123%%",
            tag
        );
        expect(result).not.toBeNull();
        expect(result!.checked).toBe(true);
        expect(result!.title).toBe("Call dentist");
        expect(result!.uuid).toBe("ABC-123");
    });

    it("parses a task with project and deadline metadata", () => {
        const result = parseLine(
            "- [ ] Fix bug #things (Work) ðŸ“… 2026-03-01 %%things:DEF-456%%",
            tag
        );
        expect(result).not.toBeNull();
        expect(result!.title).toBe("Fix bug");
        expect(result!.uuid).toBe("DEF-456");
    });

    it("returns null for non-tagged checkbox", () => {
        const result = parseLine("- [ ] Regular task", tag);
        expect(result).toBeNull();
    });

    it("returns null for non-checkbox line", () => {
        const result = parseLine("Some text #things", tag);
        expect(result).toBeNull();
    });

    it("works with custom tag", () => {
        const result = parseLine("- [ ] My task #task", "#task");
        expect(result).not.toBeNull();
        expect(result!.title).toBe("My task");
    });
});

describe("buildTaskLine", () => {
    it("builds a basic task line", () => {
        const line = buildTaskLine({
            checked: false,
            title: "Buy groceries",
            uuid: "ABC-123",
            tag: "#things",
        });
        expect(line).toBe("- [ ] Buy groceries #things %%things:ABC-123%%");
    });

    it("builds a checked task line", () => {
        const line = buildTaskLine({
            checked: true,
            title: "Done task",
            uuid: "DEF-456",
            tag: "#things",
        });
        expect(line).toBe("- [x] Done task #things %%things:DEF-456%%");
    });

    it("builds a line with project and deadline", () => {
        const line = buildTaskLine({
            checked: false,
            title: "Fix bug",
            uuid: "GHI-789",
            tag: "#things",
            projectTitle: "Work",
            deadline: "2026-03-01",
        });
        expect(line).toBe(
            "- [ ] Fix bug #things (Work) ðŸ“… 2026-03-01 %%things:GHI-789%%"
        );
    });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/markdown-scanner.test.ts`
Expected: FAIL

**Step 3: Implement Markdown Scanner**

`src/markdown-scanner.ts`:
```typescript
import { ScannedTask } from "./types";

interface ParsedLine {
    checked: boolean;
    title: string;
    uuid: string | null;
}

export function parseLine(line: string, tag: string): ParsedLine | null {
    // Escape special regex chars in the tag
    const escapedTag = tag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

    const regex = new RegExp(
        `^- \\[([ x])\\] (.+?)\\s*${escapedTag}(?:\\s.*?)?(?:\\s*%%things:([^%]+)%%)?\\s*$`
    );

    const match = line.match(regex);
    if (!match) return null;

    const checked = match[1] === "x";
    const title = match[2]!.trim();
    const uuid = match[3] || null;

    return { checked, title, uuid };
}

interface BuildTaskLineOpts {
    checked: boolean;
    title: string;
    uuid: string;
    tag: string;
    projectTitle?: string;
    deadline?: string | null;
    areaTitle?: string;
}

export function buildTaskLine(opts: BuildTaskLineOpts): string {
    const checkbox = opts.checked ? "[x]" : "[ ]";
    let line = `- ${checkbox} ${opts.title} ${opts.tag}`;

    if (opts.projectTitle) {
        line += ` (${opts.projectTitle})`;
    }
    if (opts.deadline) {
        line += ` ðŸ“… ${opts.deadline}`;
    }
    if (opts.areaTitle) {
        line += ` [${opts.areaTitle}]`;
    }

    line += ` %%things:${opts.uuid}%%`;
    return line;
}

export function extractTagFromLine(line: string, tag: string): boolean {
    return line.includes(tag);
}

export interface VaultScanner {
    scanFile(
        content: string,
        filePath: string,
        tag: string
    ): ScannedTask[];
}

export function scanFileContent(
    content: string,
    filePath: string,
    tag: string
): ScannedTask[] {
    const lines = content.split("\n");
    const tasks: ScannedTask[] = [];

    for (let i = 0; i < lines.length; i++) {
        const parsed = parseLine(lines[i]!, tag);
        if (parsed) {
            tasks.push({
                filePath,
                line: i,
                checked: parsed.checked,
                title: parsed.title,
                uuid: parsed.uuid,
                rawLine: lines[i]!,
            });
        }
    }

    return tasks;
}
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run src/markdown-scanner.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/markdown-scanner.ts src/markdown-scanner.test.ts && git commit -m "feat: add markdown scanner for tagged checkboxes"
```

---

### Task 6: Query DSL Parser

**Files:**
- Create: `src/query-parser.ts`
- Create: `src/query-parser.test.ts`

**Step 1: Write tests for query parsing**

`src/query-parser.test.ts`:
```typescript
import { describe, it, expect } from "vitest";
import { parseQuery, filterTasks } from "./query-parser";
import { ThingsTask, ThingsStatus, ThingsItemType, ThingsStart } from "./types";

describe("parseQuery", () => {
    it("parses a simple 'today' query", () => {
        const q = parseQuery("today");
        expect(q.list).toBe("today");
    });

    it("parses multiple filters", () => {
        const q = parseQuery("project: Work\nstatus: open\nsort: deadline\nlimit: 10");
        expect(q.project).toBe("Work");
        expect(q.status).toBe("open");
        expect(q.sort).toBe("deadline");
        expect(q.limit).toBe(10);
    });

    it("parses view and group", () => {
        const q = parseQuery("group: project\nview: kanban");
        expect(q.group).toBe("project");
        expect(q.view).toBe("kanban");
    });

    it("parses tag filter", () => {
        const q = parseQuery("tag: urgent");
        expect(q.tag).toBe("urgent");
    });

    it("defaults view to list", () => {
        const q = parseQuery("today");
        expect(q.view).toBe("list");
    });
});

const makeTask = (overrides: Partial<ThingsTask> = {}): ThingsTask => ({
    uuid: "test-uuid",
    title: "Test task",
    status: ThingsStatus.Open,
    type: ThingsItemType.Todo,
    notes: "",
    project: null,
    projectTitle: null,
    area: null,
    areaTitle: null,
    tags: [],
    startDate: null,
    deadline: null,
    stopDate: null,
    creationDate: 0,
    userModificationDate: 0,
    start: ThingsStart.Anytime,
    trashed: false,
    ...overrides,
});

describe("filterTasks", () => {
    it("filters by status open", () => {
        const tasks = [
            makeTask({ status: ThingsStatus.Open }),
            makeTask({ status: ThingsStatus.Completed }),
        ];
        const q = parseQuery("status: open");
        const result = filterTasks(tasks, q);
        expect(result).toHaveLength(1);
        expect(result[0]!.status).toBe(ThingsStatus.Open);
    });

    it("filters by project", () => {
        const tasks = [
            makeTask({ projectTitle: "Work" }),
            makeTask({ projectTitle: "Personal" }),
        ];
        const q = parseQuery("project: Work");
        const result = filterTasks(tasks, q);
        expect(result).toHaveLength(1);
        expect(result[0]!.projectTitle).toBe("Work");
    });

    it("filters by tag", () => {
        const tasks = [
            makeTask({ tags: ["urgent", "work"] }),
            makeTask({ tags: ["personal"] }),
        ];
        const q = parseQuery("tag: urgent");
        const result = filterTasks(tasks, q);
        expect(result).toHaveLength(1);
    });

    it("applies limit", () => {
        const tasks = [makeTask(), makeTask(), makeTask()];
        const q = parseQuery("limit: 2");
        const result = filterTasks(tasks, q);
        expect(result).toHaveLength(2);
    });

    it("sorts by deadline", () => {
        const tasks = [
            makeTask({ deadline: "2026-03-01", title: "Later" }),
            makeTask({ deadline: "2026-01-01", title: "Sooner" }),
        ];
        const q = parseQuery("sort: deadline");
        const result = filterTasks(tasks, q);
        expect(result[0]!.title).toBe("Sooner");
    });

    it("filters inbox tasks", () => {
        const tasks = [
            makeTask({ start: ThingsStart.Inbox }),
            makeTask({ start: ThingsStart.Anytime }),
        ];
        const q = parseQuery("inbox");
        const result = filterTasks(tasks, q);
        expect(result).toHaveLength(1);
        expect(result[0]!.start).toBe(ThingsStart.Inbox);
    });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/query-parser.test.ts`
Expected: FAIL

**Step 3: Implement Query Parser**

`src/query-parser.ts`:
```typescript
import { ThingsTask, ThingsStatus, ThingsStart } from "./types";

export interface ParsedQuery {
    list?: string;
    project?: string;
    area?: string;
    tag?: string;
    status?: string;
    deadline?: string;
    sort?: string;
    limit?: number;
    group?: string;
    view: "list" | "kanban" | "table";
}

export function parseQuery(source: string): ParsedQuery {
    const query: ParsedQuery = { view: "list" };
    const lines = source.trim().split("\n").map((l) => l.trim()).filter(Boolean);

    for (const line of lines) {
        const colonIdx = line.indexOf(":");
        if (colonIdx === -1) {
            // Single-word filter like "today", "inbox", "upcoming", "someday", "logbook"
            query.list = line.toLowerCase();
            continue;
        }

        const key = line.slice(0, colonIdx).trim().toLowerCase();
        const value = line.slice(colonIdx + 1).trim();

        switch (key) {
            case "project": query.project = value; break;
            case "area": query.area = value; break;
            case "tag": query.tag = value; break;
            case "status": query.status = value.toLowerCase(); break;
            case "deadline": query.deadline = value; break;
            case "sort": query.sort = value.toLowerCase(); break;
            case "limit": query.limit = parseInt(value, 10) || undefined; break;
            case "group": query.group = value.toLowerCase(); break;
            case "view":
                if (value === "kanban" || value === "table" || value === "list") {
                    query.view = value;
                }
                break;
        }
    }

    return query;
}

function getToday(): string {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
}

export function filterTasks(tasks: ThingsTask[], query: ParsedQuery): ThingsTask[] {
    let result = [...tasks];

    // List-based filters
    if (query.list) {
        switch (query.list) {
            case "today":
                const today = getToday();
                result = result.filter(
                    (t) => t.startDate === today || t.start === ThingsStart.Anytime
                );
                break;
            case "inbox":
                result = result.filter((t) => t.start === ThingsStart.Inbox);
                break;
            case "upcoming":
                result = result.filter((t) => t.startDate !== null && t.status === ThingsStatus.Open);
                break;
            case "someday":
                result = result.filter((t) => t.start === ThingsStart.Someday);
                break;
            case "logbook":
                result = result.filter((t) => t.status === ThingsStatus.Completed);
                break;
        }
    }

    // Property filters
    if (query.project) {
        result = result.filter((t) => t.projectTitle === query.project);
    }
    if (query.area) {
        result = result.filter((t) => t.areaTitle === query.area);
    }
    if (query.tag) {
        result = result.filter((t) => t.tags.includes(query.tag!));
    }
    if (query.status) {
        const statusMap: Record<string, ThingsStatus> = {
            open: ThingsStatus.Open,
            completed: ThingsStatus.Completed,
            canceled: ThingsStatus.Canceled,
        };
        const s = statusMap[query.status];
        if (s !== undefined) {
            result = result.filter((t) => t.status === s);
        }
    }

    // Sort
    if (query.sort) {
        result.sort((a, b) => {
            switch (query.sort) {
                case "deadline":
                    return (a.deadline || "9999") .localeCompare(b.deadline || "9999");
                case "title":
                    return a.title.localeCompare(b.title);
                case "project":
                    return (a.projectTitle || "").localeCompare(b.projectTitle || "");
                case "area":
                    return (a.areaTitle || "").localeCompare(b.areaTitle || "");
                default:
                    return 0;
            }
        });
    }

    // Limit
    if (query.limit) {
        result = result.slice(0, query.limit);
    }

    return result;
}
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run src/query-parser.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/query-parser.ts src/query-parser.test.ts && git commit -m "feat: add query DSL parser and filter engine"
```

---

### Task 7: Code Block Renderer

**Files:**
- Create: `src/renderer.ts`

This task has no unit tests â€” the renderer produces DOM elements which are best tested manually in Obsidian. The query logic it depends on is already tested in Task 6.

**Step 1: Implement the renderer**

`src/renderer.ts`:
```typescript
import { ThingsTask, ThingsStatus } from "./types";
import { ParsedQuery } from "./query-parser";

export interface TaskActionHandler {
    onToggle(uuid: string, completed: boolean): void;
}

function groupTasks(
    tasks: ThingsTask[],
    groupBy: string
): Record<string, ThingsTask[]> {
    const groups: Record<string, ThingsTask[]> = {};
    for (const task of tasks) {
        let key: string;
        switch (groupBy) {
            case "project":
                key = task.projectTitle || "(No Project)";
                break;
            case "area":
                key = task.areaTitle || "(No Area)";
                break;
            case "tag":
                if (task.tags.length === 0) {
                    key = "(No Tags)";
                    groups[key] = groups[key] || [];
                    groups[key]!.push(task);
                    continue;
                }
                for (const tag of task.tags) {
                    groups[tag] = groups[tag] || [];
                    groups[tag]!.push(task);
                }
                continue;
            default:
                key = "(All)";
        }
        groups[key] = groups[key] || [];
        groups[key]!.push(task);
    }
    return groups;
}

function renderTaskItem(
    container: HTMLElement,
    task: ThingsTask,
    handler: TaskActionHandler,
    showProject: boolean,
    showDeadline: boolean
): void {
    const taskEl = container.createDiv({ cls: "things-task-item" });

    const checkbox = taskEl.createEl("input", {
        type: "checkbox",
        attr: task.status === ThingsStatus.Completed ? { checked: "" } : {},
    });
    checkbox.addEventListener("change", () => {
        handler.onToggle(task.uuid, checkbox.checked);
    });

    taskEl.createSpan({ text: task.title, cls: "things-task-title" });

    if (showProject && task.projectTitle) {
        taskEl.createSpan({
            text: ` (${task.projectTitle})`,
            cls: "things-task-meta",
        });
    }

    if (showDeadline && task.deadline) {
        taskEl.createSpan({
            text: ` ðŸ“… ${task.deadline}`,
            cls: "things-task-deadline",
        });
    }
}

export function renderListView(
    el: HTMLElement,
    tasks: ThingsTask[],
    query: ParsedQuery,
    handler: TaskActionHandler,
    showProject: boolean,
    showDeadline: boolean
): void {
    const container = el.createDiv({ cls: "things-list-view" });

    if (tasks.length === 0) {
        container.createEl("p", { text: "No tasks found.", cls: "things-empty" });
        return;
    }

    if (query.group) {
        const groups = groupTasks(tasks, query.group);
        for (const [groupName, groupTasks] of Object.entries(groups)) {
            container.createEl("h4", { text: groupName, cls: "things-group-header" });
            for (const task of groupTasks) {
                renderTaskItem(container, task, handler, showProject, showDeadline);
            }
        }
    } else {
        for (const task of tasks) {
            renderTaskItem(container, task, handler, showProject, showDeadline);
        }
    }
}

export function renderKanbanView(
    el: HTMLElement,
    tasks: ThingsTask[],
    query: ParsedQuery,
    handler: TaskActionHandler,
    showProject: boolean,
    showDeadline: boolean
): void {
    const container = el.createDiv({ cls: "things-kanban-view" });

    if (tasks.length === 0) {
        container.createEl("p", { text: "No tasks found.", cls: "things-empty" });
        return;
    }

    const groupField = query.group || "project";
    const groups = groupTasks(tasks, groupField);

    for (const [groupName, groupTasks] of Object.entries(groups)) {
        const column = container.createDiv({ cls: "things-kanban-column" });
        column.createEl("h4", { text: groupName, cls: "things-kanban-header" });
        const cardContainer = column.createDiv({ cls: "things-kanban-cards" });
        for (const task of groupTasks) {
            renderTaskItem(cardContainer, task, handler, showProject, showDeadline);
        }
    }
}
```

**Step 2: Commit**

```bash
git add src/renderer.ts && git commit -m "feat: add list and kanban view renderers"
```

---

### Task 8: Sync Engine

**Files:**
- Create: `src/sync-engine.ts`
- Create: `src/sync-engine.test.ts`

**Step 1: Write tests for reconciliation logic**

`src/sync-engine.test.ts`:
```typescript
import { describe, it, expect } from "vitest";
import { reconcile, ReconcileAction } from "./sync-engine";
import { ThingsTask, ThingsStatus, ThingsItemType, ThingsStart, TrackedTask, ScannedTask } from "./types";

const makeThingsTask = (overrides: Partial<ThingsTask> = {}): ThingsTask => ({
    uuid: "UUID-1",
    title: "Test task",
    status: ThingsStatus.Open,
    type: ThingsItemType.Todo,
    notes: "",
    project: null,
    projectTitle: null,
    area: null,
    areaTitle: null,
    tags: [],
    startDate: null,
    deadline: null,
    stopDate: null,
    creationDate: 0,
    userModificationDate: 100,
    start: ThingsStart.Anytime,
    trashed: false,
    ...overrides,
});

const makeScanned = (overrides: Partial<ScannedTask> = {}): ScannedTask => ({
    filePath: "test.md",
    line: 0,
    checked: false,
    title: "Test task",
    uuid: "UUID-1",
    rawLine: "- [ ] Test task #things %%things:UUID-1%%",
    ...overrides,
});

const makeTracked = (overrides: Partial<TrackedTask> = {}): TrackedTask => ({
    uuid: "UUID-1",
    filePath: "test.md",
    line: 0,
    checked: false,
    title: "Test task",
    lastSyncTimestamp: 50,
    ...overrides,
});

describe("reconcile", () => {
    it("detects new task in Obsidian (no UUID)", () => {
        const scanned = [makeScanned({ uuid: null, title: "New task" })];
        const actions = reconcile(scanned, [], {}, "things");
        expect(actions).toHaveLength(1);
        expect(actions[0]!.type).toBe("create-in-things");
        expect(actions[0]!.title).toBe("New task");
    });

    it("detects task completed in Obsidian", () => {
        const scanned = [makeScanned({ checked: true })];
        const tracked: Record<string, TrackedTask> = {
            "UUID-1": makeTracked({ checked: false }),
        };
        const things = [makeThingsTask({ status: ThingsStatus.Open })];
        const actions = reconcile(scanned, things, tracked, "things");
        expect(actions).toHaveLength(1);
        expect(actions[0]!.type).toBe("complete-in-things");
    });

    it("detects task reopened in Obsidian", () => {
        const scanned = [makeScanned({ checked: false })];
        const tracked: Record<string, TrackedTask> = {
            "UUID-1": makeTracked({ checked: true }),
        };
        const things = [makeThingsTask({ status: ThingsStatus.Completed })];
        const actions = reconcile(scanned, things, tracked, "things");
        expect(actions).toHaveLength(1);
        expect(actions[0]!.type).toBe("reopen-in-things");
    });

    it("detects task completed in Things", () => {
        const scanned = [makeScanned({ checked: false })];
        const tracked: Record<string, TrackedTask> = {
            "UUID-1": makeTracked({ checked: false }),
        };
        const things = [makeThingsTask({ status: ThingsStatus.Completed })];
        const actions = reconcile(scanned, things, tracked, "things");
        expect(actions).toHaveLength(1);
        expect(actions[0]!.type).toBe("complete-in-obsidian");
    });

    it("detects task reopened in Things", () => {
        const scanned = [makeScanned({ checked: true })];
        const tracked: Record<string, TrackedTask> = {
            "UUID-1": makeTracked({ checked: true }),
        };
        const things = [makeThingsTask({ status: ThingsStatus.Open })];
        const actions = reconcile(scanned, things, tracked, "things");
        expect(actions).toHaveLength(1);
        expect(actions[0]!.type).toBe("reopen-in-obsidian");
    });

    it("things wins on conflict by default", () => {
        // Both changed: Obsidian checked, Things still open
        const scanned = [makeScanned({ checked: true })];
        const tracked: Record<string, TrackedTask> = {
            "UUID-1": makeTracked({ checked: false }),
        };
        // Things says: title changed but still open
        const things = [makeThingsTask({ status: ThingsStatus.Open, title: "Updated title" })];
        const actions = reconcile(scanned, things, tracked, "things");
        // Things wins: should reopen in obsidian (since things is open)
        // But obsidian just checked it... conflict: things wins means obsidian gets unchecked
        const hasReopen = actions.some((a) => a.type === "reopen-in-obsidian");
        const hasComplete = actions.some((a) => a.type === "complete-in-things");
        // Things is open, Obsidian just checked it, Things wins -> reopen in obsidian
        expect(hasReopen).toBe(true);
        expect(hasComplete).toBe(false);
    });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/sync-engine.test.ts`
Expected: FAIL

**Step 3: Implement Sync Engine reconciliation**

`src/sync-engine.ts`:
```typescript
import { ThingsTask, ThingsStatus, TrackedTask, ScannedTask } from "./types";

export type ReconcileActionType =
    | "create-in-things"
    | "complete-in-things"
    | "reopen-in-things"
    | "complete-in-obsidian"
    | "reopen-in-obsidian"
    | "update-in-obsidian";

export interface ReconcileAction {
    type: ReconcileActionType;
    uuid?: string;
    title?: string;
    filePath?: string;
    line?: number;
    thingsTask?: ThingsTask;
    scannedTask?: ScannedTask;
}

export function reconcile(
    scannedTasks: ScannedTask[],
    thingsTasks: ThingsTask[],
    trackedTasks: Record<string, TrackedTask>,
    conflictResolution: "things" | "obsidian"
): ReconcileAction[] {
    const actions: ReconcileAction[] = [];
    const thingsMap = new Map<string, ThingsTask>();
    for (const t of thingsTasks) {
        thingsMap.set(t.uuid, t);
    }

    for (const scanned of scannedTasks) {
        // Case 1: New in Obsidian â€” no UUID yet
        if (!scanned.uuid) {
            actions.push({
                type: "create-in-things",
                title: scanned.title,
                filePath: scanned.filePath,
                line: scanned.line,
                scannedTask: scanned,
            });
            continue;
        }

        const tracked = trackedTasks[scanned.uuid];
        const thingsTask = thingsMap.get(scanned.uuid);

        if (!tracked) {
            // First time seeing this UUID â€” just track it, no action
            continue;
        }

        if (!thingsTask) {
            // Task exists in Obsidian but not in Things query results
            // Could be trashed or outside query scope â€” skip
            continue;
        }

        const obsidianChanged = scanned.checked !== tracked.checked;
        const thingsCompleted = thingsTask.status === ThingsStatus.Completed;
        const thingsOpen = thingsTask.status === ThingsStatus.Open;
        const wasChecked = tracked.checked;

        if (obsidianChanged) {
            // Obsidian side changed
            const thingsAlsoChanged =
                (wasChecked && thingsOpen) || (!wasChecked && thingsCompleted);

            if (thingsAlsoChanged) {
                // Conflict â€” both sides changed
                if (conflictResolution === "things") {
                    // Things wins
                    if (thingsCompleted && !scanned.checked) {
                        actions.push({
                            type: "complete-in-obsidian",
                            uuid: scanned.uuid,
                            filePath: scanned.filePath,
                            line: scanned.line,
                            thingsTask,
                        });
                    } else if (thingsOpen && scanned.checked) {
                        actions.push({
                            type: "reopen-in-obsidian",
                            uuid: scanned.uuid,
                            filePath: scanned.filePath,
                            line: scanned.line,
                            thingsTask,
                        });
                    }
                } else {
                    // Obsidian wins
                    if (scanned.checked && !wasChecked) {
                        actions.push({
                            type: "complete-in-things",
                            uuid: scanned.uuid,
                            thingsTask,
                        });
                    } else if (!scanned.checked && wasChecked) {
                        actions.push({
                            type: "reopen-in-things",
                            uuid: scanned.uuid,
                            thingsTask,
                        });
                    }
                }
            } else {
                // Only Obsidian changed
                if (scanned.checked && !wasChecked) {
                    actions.push({
                        type: "complete-in-things",
                        uuid: scanned.uuid,
                        thingsTask,
                    });
                } else if (!scanned.checked && wasChecked) {
                    actions.push({
                        type: "reopen-in-things",
                        uuid: scanned.uuid,
                        thingsTask,
                    });
                }
            }
        } else {
            // Obsidian didn't change â€” check if Things changed
            if (thingsCompleted && !scanned.checked) {
                actions.push({
                    type: "complete-in-obsidian",
                    uuid: scanned.uuid,
                    filePath: scanned.filePath,
                    line: scanned.line,
                    thingsTask,
                });
            } else if (thingsOpen && scanned.checked) {
                actions.push({
                    type: "reopen-in-obsidian",
                    uuid: scanned.uuid,
                    filePath: scanned.filePath,
                    line: scanned.line,
                    thingsTask,
                });
            }

            // Check for title changes
            if (thingsTask.title !== tracked.title) {
                actions.push({
                    type: "update-in-obsidian",
                    uuid: scanned.uuid,
                    filePath: scanned.filePath,
                    line: scanned.line,
                    thingsTask,
                    scannedTask: scanned,
                });
            }
        }
    }

    return actions;
}
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run src/sync-engine.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/sync-engine.ts src/sync-engine.test.ts && git commit -m "feat: add sync engine reconciliation logic"
```

---

### Task 9: Settings Tab

**Files:**
- Create: `src/settings.ts`

**Step 1: Implement settings tab**

`src/settings.ts`:
```typescript
import { App, PluginSettingTab, Setting } from "obsidian";
import type ThingsSyncPlugin from "./main";
import { ThingsSyncSettings } from "./types";

export class ThingsSyncSettingTab extends PluginSettingTab {
    plugin: ThingsSyncPlugin;

    constructor(app: App, plugin: ThingsSyncPlugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;
        containerEl.empty();

        // Connection
        containerEl.createEl("h3", { text: "Connection" });

        new Setting(containerEl)
            .setName("Things database path")
            .setDesc("Leave empty for auto-detection")
            .addText((text) =>
                text
                    .setPlaceholder("Auto-detect")
                    .setValue(this.plugin.settings.dbPath)
                    .onChange(async (value) => {
                        this.plugin.settings.dbPath = value;
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Sync interval (seconds)")
            .setDesc("How often to sync with Things. Range: 10-300")
            .addSlider((slider) =>
                slider
                    .setLimits(10, 300, 5)
                    .setValue(this.plugin.settings.syncIntervalSeconds)
                    .setDynamicTooltip()
                    .onChange(async (value) => {
                        this.plugin.settings.syncIntervalSeconds = value;
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Sync on startup")
            .setDesc("Run a full sync when Obsidian launches")
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.settings.syncOnStartup)
                    .onChange(async (value) => {
                        this.plugin.settings.syncOnStartup = value;
                        await this.plugin.saveSettings();
                    })
            );

        // Task Format
        containerEl.createEl("h3", { text: "Task Format" });

        new Setting(containerEl)
            .setName("Sync tag")
            .setDesc("Tag that marks a checkbox for sync (e.g. #things, #task)")
            .addText((text) =>
                text
                    .setPlaceholder("#things")
                    .setValue(this.plugin.settings.syncTag)
                    .onChange(async (value) => {
                        this.plugin.settings.syncTag = value;
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Show project in tasks")
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.settings.showProject)
                    .onChange(async (value) => {
                        this.plugin.settings.showProject = value;
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Show deadline in tasks")
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.settings.showDeadline)
                    .onChange(async (value) => {
                        this.plugin.settings.showDeadline = value;
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Show area in tasks")
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.settings.showArea)
                    .onChange(async (value) => {
                        this.plugin.settings.showArea = value;
                        await this.plugin.saveSettings();
                    })
            );

        // Sync Behavior
        containerEl.createEl("h3", { text: "Sync Behavior" });

        new Setting(containerEl)
            .setName("Conflict resolution")
            .setDesc("When both Obsidian and Things changed since last sync")
            .addDropdown((dropdown) =>
                dropdown
                    .addOption("things", "Things wins")
                    .addOption("obsidian", "Obsidian wins")
                    .setValue(this.plugin.settings.conflictResolution)
                    .onChange(async (value: string) => {
                        this.plugin.settings.conflictResolution = value as "things" | "obsidian";
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Auto-create in Things")
            .setDesc("Automatically push new tagged checkboxes to Things")
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.settings.autoCreate)
                    .onChange(async (value) => {
                        this.plugin.settings.autoCreate = value;
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Default project")
            .setDesc("Where new tasks from Obsidian land in Things")
            .addText((text) =>
                text
                    .setPlaceholder("Inbox")
                    .setValue(this.plugin.settings.defaultProject)
                    .onChange(async (value) => {
                        this.plugin.settings.defaultProject = value;
                        await this.plugin.saveSettings();
                    })
            );

        // Advanced
        containerEl.createEl("h3", { text: "Advanced" });

        new Setting(containerEl)
            .setName("Debug logging")
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.settings.debugLogging)
                    .onChange(async (value) => {
                        this.plugin.settings.debugLogging = value;
                        await this.plugin.saveSettings();
                    })
            );

        new Setting(containerEl)
            .setName("Dry run mode")
            .setDesc("Show what sync would do without actually writing")
            .addToggle((toggle) =>
                toggle
                    .setValue(this.plugin.settings.dryRun)
                    .onChange(async (value) => {
                        this.plugin.settings.dryRun = value;
                        await this.plugin.saveSettings();
                    })
            );
    }
}
```

**Step 2: Verify it compiles**

Run: `npx tsc --noEmit`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/settings.ts && git commit -m "feat: add plugin settings tab"
```

---

### Task 10: Wire Everything Together in main.ts

**Files:**
- Modify: `src/main.ts`
- Create: `src/styles.css` (optional â€” create as `styles.css` in root)

**Step 1: Implement the full plugin main**

Replace `src/main.ts` with the full wired-up version that connects all components: settings loading, sync engine timer, code block processor registration, and vault file scanning. This is the integration point â€” it calls into Things Reader, Things Writer, Markdown Scanner, Sync Engine, Query Parser, and Renderer.

Key responsibilities of `main.ts`:
- `onload()`: load settings, find DB path, register code block processor, register sync interval, run initial sync if configured
- `runSync()`: execute one sync cycle (read DB, scan vault, reconcile, apply actions)
- `applyAction()`: for each reconcile action, call the appropriate writer or modify vault files
- Code block processor: parse query, filter cached tasks, render view
- `onunload()`: cleanup

The full implementation will be ~200 lines. Since it depends on all other modules being complete, implement it after Tasks 3-9 are done.

**Step 2: Create styles.css**

```css
.things-task-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 4px 0;
}

.things-task-title {
    flex: 1;
}

.things-task-meta {
    color: var(--text-muted);
    font-size: 0.85em;
}

.things-task-deadline {
    color: var(--text-muted);
    font-size: 0.85em;
}

.things-empty {
    color: var(--text-muted);
    font-style: italic;
}

.things-group-header {
    margin-top: 12px;
    margin-bottom: 4px;
}

.things-kanban-view {
    display: flex;
    gap: 16px;
    overflow-x: auto;
    padding: 8px 0;
}

.things-kanban-column {
    min-width: 200px;
    max-width: 300px;
    background: var(--background-secondary);
    border-radius: 8px;
    padding: 12px;
}

.things-kanban-header {
    margin: 0 0 8px 0;
    font-size: 0.9em;
    font-weight: 600;
}

.things-kanban-cards {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
```

**Step 3: Build and verify**

Run: `npm run build`
Expected: Builds successfully. `main.js` generated.

**Step 4: Commit**

```bash
git add src/main.ts styles.css && git commit -m "feat: wire up plugin main with sync engine and code block renderer"
```

---

### Task 11: Manual Integration Test

**No files to create â€” this is a manual testing task.**

**Step 1: Set up test vault**

1. Create or use an existing Obsidian vault
2. Copy `main.js`, `manifest.json`, and `styles.css` to `.obsidian/plugins/obsidian-things/`
3. Enable the plugin in Obsidian settings

**Step 2: Verify settings load**

Open Settings > Things Sync. Confirm all settings render with correct defaults.

**Step 3: Test task creation (Obsidian -> Things)**

In any note, write:
```markdown
- [ ] Test task from Obsidian #things
```

Wait for sync cycle (or check console for sync log). Verify:
- Task appears in Things 3 Inbox
- The line in Obsidian gets a UUID appended: `%%things:UUID%%`

**Step 4: Test task completion (Obsidian -> Things)**

Check the box: `- [x] Test task from Obsidian #things %%things:UUID%%`

Wait for sync. Verify task is marked complete in Things 3.

**Step 5: Test task completion (Things -> Obsidian)**

Create a task in Things 3 directly. In Obsidian, add a reference with the UUID. Complete the task in Things. Wait for sync. Verify checkbox toggles to `[x]`.

**Step 6: Test task reopening**

Uncheck a completed task in Obsidian. Wait for sync. Verify it reopens in Things 3.

**Step 7: Test code block query**

In a note, write:
````markdown
```things
today
```
````

Switch to reading view. Verify a task list renders with today's tasks from Things.

**Step 8: Commit any fixes**

```bash
git add -A && git commit -m "fix: integration test fixes"
```
